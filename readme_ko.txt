1. 소개
	Windows x64 이래로 커널은 KPP(Kernel Patch Protection)의 보호로 후킹이 불가능하다. 
	이 프로젝트는 가상화를 통해 KPP를 우회하여 커널의 네이티브 함수를 후킹하는 wdm 정적 라이브러리이다.
	KPP를 면밀히 분석한 적은 없지만 일반적으로 다음과 같이 동작한다.
	"KPP는 임의의 시간에 커널의 네이티브 함수에 대한 정적 정보와 메모리 상에 네이티브 함수의 코드를 비교해 다를 경우 BSOD를 발생시킨다."
	가상화를 통해 KPP를 우회하기 위한 아이디어는 아래와 같다.
	1. EPT를 통해 메모리를 가상화한다.
	2. 후킹할 함수에 코드 패치를 한 후 페이지 권한을 execute only로 설정한다.
	3. 해당 함수를 호출할 경우 후킹된 함수가 호출된다.
	4. 게스트 모드에서 KPP가 후킹된 함수의 메모리를 읽을 경우 호스트 모드에서 후킹된 페이지를 원래의 페이지로 변경하고 페이지 권한을 read only로 설정한다.
	5. KPP는 호스트가 핸들링한 결과인 원본 페이지를 읽는다.
	단, 호스트 모드란 VMX root mode를 의미하며 게스트 모드란 VMX Non-root mode를 의미한다.

	이 라이브러리에는 다음의 내용이 포함되어있다.
	1. 5바이트 패치는 동기화 문제가 발생할 수 있어 1바이트(int3) 패치를 수행해 트램펄린이 아닌 인터럽트 핸들링의 개념으로 후킹한다.
	2. 호스트 모드의 페이지 교체 작업에 필요한 TLB flush는 개별 코어 단위로 처리한다.
	(페이지의 상태 관리는 개별코어에 의존하지만 전체 동작에는 문제가 없다. 이해되지 않을 수 있으니 곰곰히 생각해봐라.)
	3. 호스트 모드는 IRQL의 개념을 사용할 수 없으므로 스핀락, 및 로깅에 필요한 로거를 직접 구현하였으며 포맷은 %d, %llx, %s 등 일부만을 지원한다.
	4. 하이퍼바이저의 캐시 정책은 하이퍼바이저 로드 이전 캐시 정책과 동일하다.(mtrr, pat...)
	5. EPT 페이징은 2Mb 페이지를 사용하며 후킹시 4kb로 분할한다. 후킹을 해제할 경우 분할된 4kb를 페이지를 2Mb로 병합한다.
	6. Hyper-V 와 같은 다른 하이퍼바이저와의 중첩된 가상화는 고려하지 않았다.

2. 환경
	CPU: 가상화를 지원하는 Intel cpu
	메모리: 512Gb 이하
	OS: 윈도우 10 이상(x64만 지원)

3. 구성
	1. 하이퍼바이저 라이브러리(hyperhook.lib)
	2. 하이퍼바이저 라이브러리를 링킹할 테스트 드라이버(test.sys)
	3. KMCI를 우회하기 위한 드라이버 서명관련 파일들(오직 테스트 B에서만 사용한다.)

4. 테스트
	테스트는 독립적인 A와 B로 구성된다.
	하이퍼바이저를 통한 커널 후킹을 확인하고 싶으면 테스트 A를 수행해라.
	하이퍼바이저를 통한 커널 후킹을 확인하고 KPP를 우회하는지 확인하고 싶으면 테스트 B를 수행해라.

	4.1 테스트 환경
		내가 테스트한 환경은 다음과 같다.
		vmware 15.5.7("Settings -> Hardware -> Processors -> Virtualize Intel VT-x/EPT or AMD-V/RVI" 체크)
		Guest OS: Windows 10 22h2(19041)
		만일 다른 버전의 윈도우에서 테스트할 경우 후킹할 NtCreateFile 함수의 프롤로그가 아래와 같은지 확인해라.
		sub rsp,88h
		xor eax,eax
		mov qword ptr [rsp+78h], rax

	4.2 로그 설정
		로그를 설정하기 위해 log.reg 파일을 실행해라. 아래의 내용은 로그에 대한 상세 설명을 나타낸다.
		LogType: 커널 디버거에 출력할지, 파일로 작성할지 등을 결정한다.
		1: 커널 디버거에 출력, 2: 파일로 작성, 3: 커널 디버거에 출력 및 파일로 작성

		LogLevel: 출력될 로그를 필터링한다.
		1: 에러 메시지만 출력, 2: 경고 메시지까지 출력, 3: 필터링하지 않음

		LogPath: 로그 파일이 생성될 파일 경로를 지정한다.

	4.3 테스트 A
		테스트 모드 환경의 윈도우에서 log.reg 파일을 실행한 후 test.sys 드라이버를 실행해라.(C:\HKlog.txt, windbg + VirtualKD, dbgview64 등을 통해 로그를 확인할 수 있다.)
		예상되는 결과는 다음과 같다.
		1. NtCreateFile 함수가 후킹되어 경로명을 출력한다.
		2. OriginTest 함수가 후킹되고, 함수 프롤로그의 첫 바이트가 0xCC가 아니다.
		(OriginTest 함수의 첫 바이트는 0xCC로 패치되었으나 읽기 권한으로 해당 메모리에 접근할 경우 호스트가 이를 핸들링해 후킹 전 원래 메모리를 읽는다.)

	4.4 테스트 B
		테스트 모드 환경의 윈도우에서는 KPP가 비활성화 될 수 있다. 이에 따라 KPP 우회를 직접 확인하기 위해서는 일반 모드에서 테스트해야 한다.
		이때 테스트 드라이버에 HLK/HCK 서명이 없을 경우 KMCI에 의해 로드될 수 없다.
		그러나 KMCI의 정책을 변경해 자가 서명된 드라이버를 로드하는 방법을 아래에서 설명한다.

		Host OS
		1. "Settings -> Options -> Advanced -> UEFI -> Enable secure boot"를 체크한다.
		2. Guest OS의 vmx 파일이 존재하는 폴더로 이동한다.
		3. 해당 폴더에 PK_Cert.cer를 복사한다.
		4. .nvram 파일을 삭제한다.
		5. .vmx 파일에 아래의 내용을 추가한다.
		uefi.allowAuthBypass = "TRUE"
		uefi.secureBoot.PKDefault.file0 = "PK_Cert.cer"
		6. Guest OS를 부팅한다.

		Guest OS
		1. test 폴더를 적당한 곳에 위치시킨다.
		2. SetBootPolicy.bat를 실행한다.(여러번의 재부팅이 발생한다.)
		3. SignDriver.bat를 통해 test.sys 드라이버를 서명한다.
		4. log.reg 파일을 실행한 뒤 StartDriver.bat를 통해 test.sys를 실행한다.(C:\HKlog.txt, windbg + VirtualKD, dbgview64 등을 통해 로그를 확인할 수 있다.)

		예상되는 결과는 다음과 같다.
		1. NtCreateFile 함수가 후킹되어 경로명을 출력한다.
		2. OriginTest 함수가 후킹되고, 함수 프롤로그의 첫 바이트가 0xCC가 아니다.
		(OriginTest 함수의 첫 바이트는 0xCC로 패치되었으나 읽기 권한으로 해당 메모리에 접근할 경우 호스트가 이를 핸들링해 후킹 전 원래 메모리를 읽는다.)
		3. 시간이 흘러 KPP가 NtCreateFile 함수의 메모리를 읽고 하이퍼바이저가 이를 올바르게 핸들링하여 KPP로 인한 BSOD가 발생하지 않는다.
		내 경우 로그를 통해 확인한 결과 KPP가 4시간 간격으로 NtCreateFile 함수의 무결성을 확인하였다.

		선택 사항
		1. 일반적인 커널 후킹 방식이 KPP에 의해 BSOD가 발생하는지 확인하고 싶으면 KppCheck.sys를 단독으로 실행해라.
		   아마 하루 이내에 BSOD(CRITICAL_STRUCTURE_CORRUPTION)가 발생할 것이다.
		2. SiPolicy.xml을 직접 만들고 싶을 경우 첨부된 WDACWizard를 이용해라.
		3. 배포한 인증서들을 직접 만들고 싶으면 PowerShell을 이용해라.(자세한 방법은 공개된 여러 GitHub 및 구글링을 통해 쉽게 확인할 수 있다.)
